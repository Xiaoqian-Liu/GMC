% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/GMC.R
\name{GMC}
\alias{GMC}
\title{Linear regression with the (group) GMC penalty}
\usage{
GMC(
  y,
  X,
  alpha = 0.8,
  group = 1:ncol(X),
  group.multiplier,
  nlambda = 50,
  lambdaSeq,
  lambda.min = {     if (nrow(X) > ncol(X))          0.001     else 0.05 },
  log.lambda = TRUE,
  algorithm = "PDHG",
  maxiters = 100,
  tol = 1e-06,
  returnX = FALSE,
  ShowTime = TRUE
)
}
\arguments{
\item{y}{The response vector.}

\item{X}{The design matrix without an intercept. grGMC standardizes the data and includes an intercept by default.}

\item{alpha}{The convexity-preserving parameter alpha in the group GMC penalty taking on a value between 0 and 1. Default is 0.8.}

\item{group}{A vector of length ncol(X). Each component indicates which group the corresponding covariate variable belongs to.}

\item{group.multiplier}{The weight vector for the group GMC penalty.}

\item{nlambda}{The number of values for the regularization parameter. Default is 50. The function will automatically computes
a grid of 'nlambda' lambda values with the first one producing a zero solution.}

\item{lambdaSeq}{A user-specified sequence of decrasing lambda values. It is typically left unspecified and let the function automatically
computes a grid of 'nlambda' lambda values.}

\item{lambda.min}{The smallest lambda value, as a fraction of the maximum lambda.
Default is .001 if the number of observations is larger than the number of covariates and .05 otherwise.}

\item{log.lambda}{Whether to compute the grid values of lambda on log scale (default) or linear scale. Default is TRUE.}

\item{algorithm}{Which algorithm to use for solving the group GMC problem. PDHG (default) or FB.
We recommend using PDHG for large value and FB for small alpha.}

\item{maxiters}{The maximal number of iterations. Typically, PDHG only needs 100 but FB needs 1e4.}

\item{tol}{A tolerance for early stopping. Default is 1e-6.}

\item{returnX}{Whether to return the standardized data.}

\item{ShowTime}{Whether to show the time cost for computing the solution path.}
}
\value{
\code{beta} The fitted matrix of coefficients.
The number of rows equals to the number of coefficients plus one (intercept),
and the number of columns equals to the length of the lambda sequence.

\code{family} Only "gaussian" is allowed for now.

\code{penalty} We call our penalty as GMC.

\code{group} Same as the argument 'group'.

\code{lambdaSeq} The sequence of lambda values for the solution path.

\code{alpha} Same as the argument 'alpha'.

\code{iters} A vector containing the number of iterations
for the algorithm to compute each solution.

\code{bb} The fitted matrix of coefficients for the standardized data.
 This return is used as a warm start when having a sequence of lambda.

\code{group.multiplier} A named vector containing the multiplicative constant
 applied to each group's penalty.
}
\description{
\code{GMC} fit regularization paths for linear regression with the (group) GMC penalty
over a grid of values for the regularization parameter lambda.
}
\examples{
set.seed(1234)
n <- 50
p <- 10
# true coefficients
beta <- rep(0, p)
beta[1:4] <- c(1,1,-1,-1)
# group information
group <- rep(1:5, each=p/5)
# set the group weights
gp <- unique(group)
J <- length(gp)
K <- rep(0,J)
for (j in 1:J) {
  K[j] <- sqrt(length(which(group==gp[j])))
}

# design matrix
X <- matrix(rnorm(n*p), nrow = n)
# response
y <- as.vector(X\%*\%beta+rnorm(n, mean=0, sd = 0.5))

# fit with grGMC function
fit_GMC <- GMC(y=y, X=X, alpha=0.9, group=group, group.multiplier=K, nlambda = 50, ShowTime=FALSE)
}
\author{
Xiaoqian Liu
}
